### Java程序运行时的内存结构 
[具体看](https://www.cnblogs.com/eason-chan/p/3644660.html)
方法区、栈内存、堆内存、本地方法栈

上帝 object类

* 向下转型(又称强转)

    为了让下类型保持自身特性。
    但向下转型是危险的。

    所以我们优先考虑上转型(继承抽象类，实现接口)

* 栈(stack)与堆(heap)都是Java用来在Ram中存放数据的地方。与C++不同，Java自动管理栈和堆，程序员不能直接地设置栈或堆。
* 栈：
```
栈的优势是，存取速度比堆要快，仅次于寄存器，栈数据可以共享。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。栈中主要存放一些基本类型的变量（int, short, long, byte, float, double, boolean, char）和对象句柄。

一种是基本类型(primitive types), 共有8种，即int, short, long, byte, float, double, boolean, char(注意，并没有string的基本类型)。这种类型的定义是通过诸如int a = 3; long b = 255L;的形式来定义的，称为自动变量。值得注意的是，自动变量存的是字面值，不是类的实例，即不是类的引用，这里并没有类的存在。如int a = 3; 这里的a是一个指向int类型的引用，指向3这个字面值。这些字面值的数据，由于大小可知，生存期可知(这些字面值固定定义在某个程序块里面，程序块退出后，字段值就消失了)，出于追求速度的原因，就存在于栈中。

另外，栈有一个很重要的特殊性，就是存在栈中的`数据可以共享`。
int a = 3; 
int b = 3； 
编译器先处理int a = 3；首先它会在栈中创建一个变量为a的引用，然后查找有没有字面值为3的地址，没找到，就开辟一个存放3这个字面值的地址，然后将a指向3的地址。接着处理int b = 3；在创建完b的引用变量后，由于在栈中已经有3这个字面值，便将b直接指向3的地址。这样，就出现了a与b同时均指向3的情况。
```

* 堆：
```
另一种是包装类数据，如Integer, String, Double等将相应的基本数据类型包装起来的类。这些类数据全部存在于堆中，Java用new()语句来显示地告诉编译器，在运行时才根据需要动态创建，因此比较灵活，但缺点是要占用更多的时间。
    所以，String出现了常量池。实现对象共享。

用new()来新建对象的，都会在堆中创建，而且其字符串是单独存值的，即使与栈中的数据相同，也不会与栈中的数据共享。
```
    
* 编译期和运行期

### static
* static的变量是在类装载的时候就会被初始化，即，只要类被装载，不管是否使用了static变量，都会被初始化。
* static的基本规则
1. 一个类的静态方法只能访问静态属性
2. 一个类的静态方法不能直接调用非静态方法
3. 如访问控制权限允许，static属性和方法可以使用类名加"."的方式调用，也可以使用实例加"."的方式调用
4. 静态方法中不存在当前对象，因而不能使用this，也不能使用super
5. 静态方法不能被非静态方法覆盖
6. 构造方法不允许声明为static的

7. 注，非静态变量只限于实例，并只能通过实例引用被访问。

* 静态块

    静态初始器是一个存在与类中方法外面的静态块，仅仅在类装载的时候执行一次，通常用来初始化静态的类属性。

### 抽象方法和接口
* 将共有属性和行为放在抽象类中，将特有的属性和行为放在接口中。

### 超类(就是被继承的父类)
* 超类(SuperClass) ：用java术语来讲,被继承的类称为超类(SuperClass)，也有叫做父类，继承的类称为子类。